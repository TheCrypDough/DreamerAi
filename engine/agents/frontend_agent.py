# C:\DreamerAI\engine\agents\frontend_agent.py

import asyncio
import os
import traceback
from typing import Optional, Any, Dict
from pathlib import Path

# Add project root for sibling imports
import sys
project_root_fe = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if project_root_fe not in sys.path:
    sys.path.insert(0, project_root_fe)

try:
    from engine.agents.base import BaseAgent, AgentState, Message
    from engine.ai.llm import LLM
    from engine.core.logger import logger_instance as logger, log_rules_check
    from engine.agents.agent_utils import save_code_to_file
except ImportError as e:
    print(f"Error importing modules in frontend_agent.py: {e}")
    # Dummy classes / functions for parsing
    class BaseAgent:
        def __init__(self, *args, **kwargs): self.logger=print; self.name="DummyFE"; self.memory=Memory()
    class AgentState: IDLE,RUNNING,FINISHED,ERROR = 1,2,3,4
    class Message: pass
    class Memory:
        def add_message(self, *args, **kwargs):
            pass # Define method body properly
    class LLM:
        def generate(self, *args, **kwargs):
             return "Placeholder FE Code Error"
    import logging
    logger = logging.getLogger(__name__)
    def log_rules_check(action): logger.info(f"RULES CHECK (import failed): {action}")


FRONTEND_AGENT_NAME = "Lamar"

class LamarAgent(BaseAgent):
    """
    Lamar: The Frontend Coding Agent. Generates React/JS code from blueprint.
    V1 focuses on generating a basic App component.
    """
    def __init__(self, user_dir: str, **kwargs):
        super().__init__(name=FRONTEND_AGENT_NAME, user_dir=user_dir, **kwargs)
        # Assign to _llm as per BaseAgent design
        self._llm = LLM()
        logger.info(f"LamarAgent '{self.name}' initialized.")

    async def run(self, blueprint_content: str, project_output_path: str) -> Dict[str, Any]:
        """Generates frontend code based on the blueprint."""
        self.state = AgentState.RUNNING
        log_rules_check(f"Running {self.name} to generate frontend code.")
        logger.info(f"'{self.name}' starting frontend code generation...")
        self.memory.add_message(Message(role="system", content="Task: Generate frontend code based on blueprint."))

        # Define target paths
        output_dir = Path(project_output_path) / "frontend" / "src" # Target output dir: output/frontend/src
        output_file = output_dir / "App.jsx" # Target output file

        prompt = f"""
        **Role:** You are Lamar, a specialist Frontend Developer AI for DreamerAI.
        **Task:** Generate React code for a frontend application based on the project blueprint below.
        **Target Framework:** React.js with JavaScript (JSX). Assume standard setup (`create-react-app` or similar). Use functional components and hooks. Include basic Material-UI component examples if relevant based on blueprint.
        **Project Blueprint:**
        ```markdown
        {blueprint_content}
        ```
        **Output Requirements:**
        - Generate a single React functional component file (`App.jsx`).
        - Include necessary React imports (`import React from 'react';`, maybe `useState`).
        - Create the main `App` component structure (`function App() {{ return (...); }}`).
        - Render simple JSX based on the blueprint's core features or summary (e.g., an `<h1>` with the project title, placeholder `div`s for features).
        - Include `export default App;`.
        - Ensure the code is clean, uses standard JSX syntax, and follows basic React best practices.
        - **ONLY output the raw JSX/JavaScript code for App.jsx. Do not include explanations, import statements for libraries unless asked, or markdown formatting.**
        """

        try:
            logger.debug("Requesting LLM generation for frontend code...")
            # Use default model preference for Lamar in V1
            generated_code = await self._llm.generate(prompt, max_tokens=2500) # Use _llm

            if generated_code.startswith("ERROR:"):
                logger.error(f"LLM generation failed for {self.name}: {generated_code}")
                self.state = AgentState.ERROR
                return {"status": "error", "message": f"LLM failed: {generated_code}"}

            # Basic cleanup of potential LLM fences
            generated_code = generated_code.strip().strip('```jsx').strip('```javascript').strip('```').strip()

            self.memory.add_message(Message(role="assistant", content=f"Generated frontend code snippet: {generated_code[:150]}..."))
            logger.info(f"Frontend code generated by {self.name}.")

            # Save the code using the helper
            if save_code_to_file(output_file, generated_code):
                self.state = AgentState.FINISHED
                return {"status": "success", "file_path": str(output_file)}
            else:
                self.state = AgentState.ERROR
                return {"status": "error", "message": f"Failed to save frontend code to {output_file}"}

        except Exception as e:
            self.state = AgentState.ERROR
            error_msg = f"Unexpected error during {self.name} run: {e}" # General error message
            logger.exception(error_msg)
            return {"status": "error", "message": error_msg}
        finally:
             current_state = self.state
             if current_state == AgentState.FINISHED:
                 self.state = AgentState.IDLE # Reset to IDLE after successful run
             logger.info(f"'{self.name}' run finished. Final state: {self.state} (was {current_state})")

    async def step(self, input_data: Optional[Any] = None) -> Any:
         logger.warning(f"{self.name}.step() called, but run() expects specific args. Step not supported in V1.")
         self.state = AgentState.ERROR
         return {"error": f"{self.name} cannot be executed via step() in V1."} 